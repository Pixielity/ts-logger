{"version":3,"sources":["../../src/interfaces/context/manager.interface.ts","../../src/interfaces/context/management.interface.ts","../../src/interfaces/events/event-dispatcher.interface.ts","../../src/interfaces/utils/exception-formatter.interface.ts","../../src/interfaces/processors/context-log-processor.interface.ts","../../src/context/manager.ts","../../src/context/events/dehydrating.event.ts","../../src/context/events/hydrated.event.ts","../../src/context/repository.ts","../../src/utils/exception-formatter.ts","../../src/processors/context-log-processor.ts","../../src/providers/context-service-provider.ts"],"names":["IContextManager","IContextManagement","IEventDispatcher","IExceptionFormatter","IContextLogProcessor","injectable"],"mappings":"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","file":"context-service-provider.mjs","sourcesContent":["import type { LogContext } from '../../types/log-context.type'\n\n/**\n * IContextManager defines the contract for context managers.\n * It provides methods for managing contextual data across components.\n */\nexport interface IContextManager {\n  /**\n   * Add contextual data\n   * @param context The contextual data to add\n   */\n  addContext(context: LogContext): void\n\n  /**\n   * Remove contextual data\n   * @param keys The keys to remove from the context\n   */\n  removeContext(keys: string[]): void\n\n  /**\n   * Get all contextual data\n   */\n  getContext(): LogContext\n\n  /**\n   * Clear all contextual data\n   */\n  clearContext(): void\n\n  /**\n   * Create a scoped context manager\n   */\n  createScope(): IContextManager\n\n  /**\n   * Merge contextual data from another context manager\n   * @param manager The context manager to merge from\n   */\n  merge(manager: IContextManager): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContextManager {\n  /**\n   * Symbol for injecting the context manager\n   */\n  export const $ = Symbol.for('IContextManager')\n}\n","import type { LogContext } from '../../types/log-context.type'\n\n/**\n * IContextManagement defines the contract for context management.\n * It provides methods for managing contextual data.\n */\nexport interface IContextManagement {\n  /**\n   * Add a value to the context\n   * @param key The context key\n   * @param value The context value\n   */\n  add(key: string, value: any): void\n\n  /**\n   * Get a value from the context\n   * @param key The context key\n   * @param defaultValue The default value to return if the key is not found\n   */\n  get<T>(key: string, defaultValue?: T): T\n\n  /**\n   * Check if the context contains a key\n   * @param key The context key\n   */\n  has(key: string): boolean\n\n  /**\n   * Remove a value from the context\n   * @param key The context key\n   */\n  forget(key: string): void\n\n  /**\n   * Add a hidden value to the context\n   * @param key The context key\n   * @param value The context value\n   */\n  addHidden(key: string, value: any): void\n\n  /**\n   * Get a hidden value from the context\n   * @param key The context key\n   * @param defaultValue The default value to return if the key is not found\n   */\n  getHidden<T>(key: string, defaultValue?: T): T\n\n  /**\n   * Check if the context contains a hidden key\n   * @param key The context key\n   */\n  hasHidden(key: string): boolean\n\n  /**\n   * Remove a hidden value from the context\n   * @param key The context key\n   */\n  forgetHidden(key: string): void\n\n  /**\n   * Push a value onto a stack in the context\n   * @param key The context key\n   * @param value The value to push\n   */\n  push(key: string, value: any): void\n\n  /**\n   * Pop a value from a stack in the context\n   * @param key The context key\n   */\n  pop<T>(key: string): T | undefined\n\n  /**\n   * Check if a stack in the context contains a value\n   * @param key The context key\n   * @param value The value to check for\n   */\n  stackContains(key: string, value: any): boolean\n\n  /**\n   * Increment a counter in the context\n   * @param key The context key\n   * @param amount The amount to increment by\n   */\n  increment(key: string, amount?: number): number\n\n  /**\n   * Decrement a counter in the context\n   * @param key The context key\n   * @param amount The amount to decrement by\n   */\n  decrement(key: string, amount?: number): number\n\n  /**\n   * Create a scoped context\n   * @param callback The callback function to execute with the scoped context\n   */\n  scope<T>(callback: () => T): T\n\n  /**\n   * Dehydrate the context to a serializable object\n   */\n  dehydrate(): Record<string, any>\n\n  /**\n   * Hydrate the context from a serialized object\n   * @param data The serialized context data\n   */\n  hydrate(data: Record<string, any>): void\n\n  /**\n   * Get all context data\n   */\n  all(): LogContext\n\n  /**\n   * Clear all context data\n   */\n  clear(): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContextManagement {\n  /**\n   * Symbol for injecting the context management\n   */\n  export const $ = Symbol.for('IContextManagement')\n}\n","import type { ILogEvent } from './log-event.interface'\nimport type { LogListener } from '../../types/log-listener.type'\n\n/**\n * IEventDispatcher defines the contract for event dispatchers.\n * It provides methods for dispatching events and managing event listeners.\n */\nexport interface IEventDispatcher {\n  /**\n   * Dispatch an event\n   * @param event The event to dispatch\n   */\n  dispatch(event: ILogEvent): void\n\n  /**\n   * Add a listener for an event\n   * @param eventName The event name\n   * @param listener The event listener\n   */\n  addListener(eventName: string, listener: LogListener): void\n\n  /**\n   * Remove a listener for an event\n   * @param eventName The event name\n   * @param listener The event listener\n   */\n  removeListener(eventName: string, listener: LogListener): void\n\n  /**\n   * Get all listeners for an event\n   * @param eventName The event name\n   */\n  getListeners(eventName: string): LogListener[]\n\n  /**\n   * Check if an event has listeners\n   * @param eventName The event name\n   */\n  hasListeners(eventName: string): boolean\n\n  /**\n   * Remove all listeners for an event\n   * @param eventName The event name\n   */\n  clearListeners(eventName: string): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IEventDispatcher {\n  /**\n   * Symbol for injecting the event dispatcher\n   */\n  export const $ = Symbol.for('IEventDispatcher')\n}\n","/**\n * IExceptionFormatter defines the contract for exception formatters.\n * It provides methods for formatting exceptions.\n */\nexport interface IExceptionFormatter {\n  /**\n   * Format an exception\n   * @param exception The exception to format\n   */\n  format(exception: Error): Promise<string>\n\n  /**\n   * Get the stack trace from an exception\n   * @param exception The exception to get the stack trace from\n   */\n  getStackTrace(exception: Error): Promise<string>\n\n  /**\n   * Enable or disable color support\n   * @param enabled Whether color support is enabled\n   */\n  setColorSupport(enabled: boolean): void\n\n  /**\n   * Get whether color support is enabled\n   */\n  isColorSupportEnabled(): boolean\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IExceptionFormatter {\n  /**\n   * Symbol for injecting the exception formatter\n   */\n  export const $ = Symbol.for('IExceptionFormatter')\n}\n","import type { ILogProcessor } from './log-processor.interface'\nimport type { LogContext } from '../../types/log-context.type'\n\n/**\n * IContextLogProcessor defines the contract for context log processors.\n * It provides methods for adding contextual data to log records.\n */\nexport interface IContextLogProcessor extends ILogProcessor {\n  /**\n   * Add contextual data to all subsequent log records\n   * @param context The contextual data to add\n   */\n  addContext(context: LogContext): void\n\n  /**\n   * Remove contextual data from all subsequent log records\n   * @param keys The keys to remove from the context\n   */\n  removeContext(keys: string[]): void\n\n  /**\n   * Get the current context\n   */\n  getContext(): LogContext\n\n  /**\n   * Clear the current context\n   */\n  clearContext(): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IContextLogProcessor {\n  /**\n   * Symbol for injecting the context log processor\n   */\n  export const $ = Symbol.for('IContextLogProcessor')\n}\n","import { injectable, inject } from 'inversify'\nimport type { IContextManager } from '../interfaces/context/manager.interface'\nimport { IContextManagement } from '../interfaces/context/management.interface'\nimport type { LogContext } from '../types/log-context.type'\n\n/**\n * ContextManager is an implementation of the IContextManager interface.\n * It provides methods for managing contextual data across components.\n */\n@injectable()\nexport class ContextManager implements IContextManager {\n  private context: LogContext = {}\n  private parent: IContextManager | null = null\n  private contextRepository: IContextManagement\n\n  /**\n   * Create a new ContextManager instance\n   * @param contextRepository The context repository to use\n   */\n  constructor(@inject(IContextManagement.$) contextRepository: IContextManagement) {\n    this.contextRepository = contextRepository\n  }\n\n  /**\n   * Add contextual data\n   * @param context The contextual data to add\n   */\n  public addContext(context: LogContext): void {\n    this.context = { ...this.context, ...context }\n\n    // Add the context to the repository\n    for (const [key, value] of Object.entries(context)) {\n      this.contextRepository.add(key, value)\n    }\n  }\n\n  /**\n   * Remove contextual data\n   * @param keys The keys to remove from the context\n   */\n  public removeContext(keys: string[]): void {\n    const newContext: LogContext = { ...this.context }\n    for (const key of keys) {\n      delete newContext[key]\n      this.contextRepository.forget(key)\n    }\n    this.context = newContext\n  }\n\n  /**\n   * Get all contextual data\n   */\n  public getContext(): LogContext {\n    return this.context\n  }\n\n  /**\n   * Clear all contextual data\n   */\n  public clearContext(): void {\n    this.context = {}\n  }\n\n  /**\n   * Create a scoped context manager\n   */\n  public createScope(): IContextManager {\n    const scopedManager = new ContextManager(this.contextRepository)\n    scopedManager.parent = this\n    return scopedManager\n  }\n\n  /**\n   * Merge contextual data from another context manager\n   * @param manager The context manager to merge from\n   */\n  public merge(manager: IContextManager): void {\n    this.addContext(manager.getContext())\n  }\n}\n","import type { IContextDehydrating } from '../../interfaces/events/dehydrating.interface'\nimport type { LogContext } from '../../types/log-context.type'\n\n/**\n * ContextDehydratingEvent is an implementation of the IContextDehydrating interface.\n * It represents an event that is dispatched when the context is being dehydrated.\n */\nexport class ContextDehydratingEvent implements IContextDehydrating {\n  private name = 'context.dehydrating'\n  private timestamp: Date = new Date()\n  private context: LogContext\n\n  /**\n   * Create a new ContextDehydratingEvent instance\n   * @param context The context data being dehydrated\n   */\n  constructor(context: LogContext) {\n    this.context = context\n  }\n\n  /**\n   * Get the event name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Get the event data\n   */\n  public getData(): Record<string, any> {\n    return {\n      context: this.context,\n    }\n  }\n\n  /**\n   * Get the event timestamp\n   */\n  public getTimestamp(): Date {\n    return this.timestamp\n  }\n\n  /**\n   * Get the context data being dehydrated\n   */\n  public getContext(): LogContext {\n    return this.context\n  }\n\n  /**\n   * Set the context data being dehydrated\n   * @param context The context data\n   */\n  public setContext(context: LogContext): void {\n    this.context = context\n  }\n}\n","import type { IContextHydrated } from '../../interfaces/events/hydrated.interface'\nimport type { LogContext } from '../../types/log-context.type'\n\n/**\n * ContextHydratedEvent is an implementation of the IContextHydrated interface.\n * It represents an event that is dispatched when the context has been hydrated.\n */\nexport class ContextHydratedEvent implements IContextHydrated {\n  private name = 'context.hydrated'\n  private timestamp: Date = new Date()\n  private context: LogContext\n  private source: string\n\n  /**\n   * Create a new ContextHydratedEvent instance\n   * @param context The context data that was hydrated\n   * @param source The source of the hydrated data\n   */\n  constructor(context: LogContext, source: string) {\n    this.context = context\n    this.source = source\n  }\n\n  /**\n   * Get the event name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Get the event data\n   */\n  public getData(): Record<string, any> {\n    return {\n      context: this.context,\n      source: this.source,\n    }\n  }\n\n  /**\n   * Get the event timestamp\n   */\n  public getTimestamp(): Date {\n    return this.timestamp\n  }\n\n  /**\n   * Get the context data that was hydrated\n   */\n  public getContext(): LogContext {\n    return this.context\n  }\n\n  /**\n   * Get the source of the hydrated data\n   */\n  public getSource(): string {\n    return this.source\n  }\n}\n","import { injectable } from 'inversify'\nimport type { IContextManagement } from '../interfaces/context/management.interface'\nimport type { IEventDispatcher } from '../interfaces/events/event-dispatcher.interface'\nimport type { LogContext } from '../types/log-context.type'\nimport { ContextDehydratingEvent } from './events/dehydrating.event'\nimport { ContextHydratedEvent } from './events/hydrated.event'\n\n/**\n * ContextRepository is an implementation of the IContextManagement interface.\n * It provides methods for managing contextual data.\n */\n@injectable()\nexport class ContextRepository implements IContextManagement {\n  private context: LogContext = {}\n  private hiddenContext: LogContext = {}\n  private stacks: Record<string, any[]> = {}\n  private counters: Record<string, number> = {}\n  private eventDispatcher: IEventDispatcher\n\n  /**\n   * Create a new ContextRepository instance\n   * @param eventDispatcher The event dispatcher to use\n   */\n  constructor(eventDispatcher: IEventDispatcher) {\n    this.eventDispatcher = eventDispatcher\n  }\n\n  /**\n   * Add a value to the context\n   * @param key The context key\n   * @param value The context value\n   */\n  public add(key: string, value: any): void {\n    this.context[key] = value\n  }\n\n  /**\n   * Get a value from the context\n   * @param key The context key\n   * @param defaultValue The default value to return if the key is not found\n   */\n  public get<T>(key: string, defaultValue?: T): T {\n    return (this.context[key] as T) ?? (defaultValue as T)\n  }\n\n  /**\n   * Check if the context contains a key\n   * @param key The context key\n   */\n  public has(key: string): boolean {\n    return key in this.context\n  }\n\n  /**\n   * Remove a value from the context\n   * @param key The context key\n   */\n  public forget(key: string): void {\n    delete this.context[key]\n  }\n\n  /**\n   * Add a hidden value to the context\n   * @param key The context key\n   * @param value The context value\n   */\n  public addHidden(key: string, value: any): void {\n    this.hiddenContext[key] = value\n  }\n\n  /**\n   * Get a hidden value from the context\n   * @param key The context key\n   * @param defaultValue The default value to return if the key is not found\n   */\n  public getHidden<T>(key: string, defaultValue?: T): T {\n    return (this.hiddenContext[key] as T) ?? (defaultValue as T)\n  }\n\n  /**\n   * Check if the context contains a hidden key\n   * @param key The context key\n   */\n  public hasHidden(key: string): boolean {\n    return key in this.hiddenContext\n  }\n\n  /**\n   * Remove a hidden value from the context\n   * @param key The context key\n   */\n  public forgetHidden(key: string): void {\n    delete this.hiddenContext[key]\n  }\n\n  /**\n   * Push a value onto a stack in the context\n   * @param key The context key\n   * @param value The value to push\n   */\n  public push(key: string, value: any): void {\n    if (!this.stacks[key]) {\n      this.stacks[key] = []\n    }\n    this.stacks[key].push(value)\n  }\n\n  /**\n   * Pop a value from a stack in the context\n   * @param key The context key\n   */\n  public pop<T>(key: string): T | undefined {\n    if (!this.stacks[key] || this.stacks[key].length === 0) {\n      return undefined\n    }\n    return this.stacks[key].pop() as T\n  }\n\n  /**\n   * Check if a stack in the context contains a value\n   * @param key The context key\n   * @param value The value to check for\n   */\n  public stackContains(key: string, value: any): boolean {\n    if (!this.stacks[key]) {\n      return false\n    }\n    return this.stacks[key].includes(value)\n  }\n\n  /**\n   * Increment a counter in the context\n   * @param key The context key\n   * @param amount The amount to increment by\n   */\n  public increment(key: string, amount = 1): number {\n    if (!this.counters[key]) {\n      this.counters[key] = 0\n    }\n    this.counters[key] += amount\n    return this.counters[key]\n  }\n\n  /**\n   * Decrement a counter in the context\n   * @param key The context key\n   * @param amount The amount to decrement by\n   */\n  public decrement(key: string, amount = 1): number {\n    if (!this.counters[key]) {\n      this.counters[key] = 0\n    }\n    this.counters[key] -= amount\n    return this.counters[key]\n  }\n\n  /**\n   * Create a scoped context\n   * @param callback The callback function to execute with the scoped context\n   */\n  public scope<T>(callback: () => T): T {\n    // Save the current context\n    const savedContext = { ...this.context }\n    const savedHiddenContext = { ...this.hiddenContext }\n    const savedStacks = { ...this.stacks }\n    const savedCounters = { ...this.counters }\n\n    try {\n      // Execute the callback\n      return callback()\n    } finally {\n      // Restore the context\n      this.context = savedContext\n      this.hiddenContext = savedHiddenContext\n      this.stacks = savedStacks\n      this.counters = savedCounters\n    }\n  }\n\n  /**\n   * Dehydrate the context to a serializable object\n   */\n  public dehydrate(): Record<string, any> {\n    // Create a dehydrated context\n    const dehydratedContext: Record<string, any> = {\n      context: { ...this.context },\n      counters: { ...this.counters },\n    }\n\n    // Dispatch a ContextDehydrating event\n    const event = new ContextDehydratingEvent(dehydratedContext.context)\n    this.eventDispatcher.dispatch(event)\n\n    // Update the dehydrated context with any changes made by event listeners\n    dehydratedContext.context = event.getContext()\n\n    return dehydratedContext\n  }\n\n  /**\n   * Hydrate the context from a serialized object\n   * @param data The serialized context data\n   */\n  public hydrate(data: Record<string, any>): void {\n    try {\n      // Hydrate the context\n      if (data.context) {\n        this.context = { ...this.context, ...data.context }\n      }\n      if (data.counters) {\n        this.counters = { ...this.counters, ...data.counters }\n      }\n\n      // Dispatch a ContextHydrated event\n      const event = new ContextHydratedEvent(this.context, 'dehydrated')\n      this.eventDispatcher.dispatch(event)\n    } catch (error) {\n      console.error('Failed to hydrate context:', error)\n    }\n  }\n\n  /**\n   * Get all context data\n   */\n  public all(): LogContext {\n    return { ...this.context }\n  }\n\n  /**\n   * Clear all context data\n   */\n  public clear(): void {\n    this.context = {}\n    this.hiddenContext = {}\n    this.stacks = {}\n    this.counters = {}\n  }\n}\n","import { injectable } from 'inversify'\nimport StackTrace from 'stacktrace-js'\n\nimport type { IExceptionFormatter } from '../interfaces/utils/exception-formatter.interface'\n\n/**\n * ExceptionFormatter is an implementation of the IExceptionFormatter interface.\n * It provides methods for formatting exceptions.\n */\n@injectable()\nexport class ExceptionFormatter implements IExceptionFormatter {\n  private colorSupport = true\n\n  /**\n   * Create a new ExceptionFormatter instance\n   * @param options Options for the formatter\n   */\n  constructor(options: { colorSupport?: boolean } = {}) {\n    if (options.colorSupport !== undefined) {\n      this.colorSupport = options.colorSupport\n    }\n  }\n\n  /**\n   * Format an exception\n   * @param exception The exception to format\n   */\n  public async format(exception: Error): Promise<string> {\n    const message = exception.message\n    const name = exception.name\n    const stack = await this.getStackTrace(exception)\n\n    // Format the exception\n    let formatted = `${name}: ${message}\\n${stack}`\n\n    // Add color if enabled\n    if (this.colorSupport) {\n      formatted = `%c${formatted}`\n      // Note: In a browser environment, this would be used with console.log\n      // console.log(formatted, \"color: #FF0000\")\n    }\n\n    return formatted\n  }\n\n  /**\n   * Get the stack trace from an exception\n   * @param exception The exception to get the stack trace from\n   */\n  public async getStackTrace(exception: Error): Promise<string> {\n    // Use stacktrace-js to get a formatted stack trace\n    try {\n      const stackFrames = await StackTrace.fromError(exception)\n      return this.formatStackFrames(stackFrames)\n    } catch (error) {\n      // Fall back to the native stack trace\n      return exception.stack || ''\n    }\n  }\n\n  /**\n   * Format stack frames\n   * @param stackFrames The stack frames to format\n   */\n  private formatStackFrames(stackFrames: any[]): string {\n    return stackFrames\n      .map((frame) => {\n        const fileName = frame.fileName || '<anonymous>'\n        const lineNumber = frame.lineNumber || '?'\n        const columnNumber = frame.columnNumber || '?'\n        const functionName = frame.functionName || '<anonymous>'\n        return `    at ${functionName} (${fileName}:${lineNumber}:${columnNumber})`\n      })\n      .join('\\n')\n  }\n\n  /**\n   * Enable or disable color support\n   * @param enabled Whether color support is enabled\n   */\n  public setColorSupport(enabled: boolean): void {\n    this.colorSupport = enabled\n  }\n\n  /**\n   * Get whether color support is enabled\n   */\n  public isColorSupportEnabled(): boolean {\n    return this.colorSupport\n  }\n}\n","import { injectable } from 'inversify'\n\nimport type { LogContext, LogRecord } from '../types'\nimport { ProcessorType } from '../enums/processor-type.enum'\nimport type { IContextLogProcessor } from '../interfaces/processors/context-log-processor.interface'\n\n/**\n * ContextLogProcessor is an implementation of the IContextLogProcessor interface.\n * It adds contextual data to log records.\n */\n@injectable()\nexport class ContextLogProcessor implements IContextLogProcessor {\n  private name = ProcessorType.CONTEXT\n  private context: LogContext = {}\n\n  /**\n   * Create a new ContextLogProcessor instance\n   * @param context Initial context\n   */\n  constructor(context: LogContext = {}) {\n    this.context = context\n  }\n\n  /**\n   * Process a log record\n   * @param record The log record to process\n   */\n  public process(record: LogRecord): LogRecord {\n    // Merge the processor's context with the record's context\n    const mergedContext = { ...this.context, ...record.context }\n\n    // Return the updated record\n    return {\n      ...record,\n      context: mergedContext,\n    }\n  }\n\n  /**\n   * Add contextual data to all subsequent log records\n   * @param context The contextual data to add\n   */\n  public addContext(context: LogContext): void {\n    this.context = { ...this.context, ...context }\n  }\n\n  /**\n   * Remove contextual data from all subsequent log records\n   * @param keys The keys to remove from the context\n   */\n  public removeContext(keys: string[]): void {\n    const newContext: LogContext = { ...this.context }\n    for (const key of keys) {\n      delete newContext[key]\n    }\n    this.context = newContext\n  }\n\n  /**\n   * Get the current context\n   */\n  public getContext(): LogContext {\n    return this.context\n  }\n\n  /**\n   * Clear the current context\n   */\n  public clearContext(): void {\n    this.context = {}\n  }\n\n  /**\n   * Get the processor name\n   */\n  public getName(): string {\n    return this.name\n  }\n}\n","import { injectable } from 'inversify'\nimport { ServiceProvider } from '@pixielity/ts-application'\n\n// Import all interfaces with their namespaces\nimport { IContextManager } from '../interfaces/context/manager.interface'\nimport { IContextManagement } from '../interfaces/context/management.interface'\nimport { IEventDispatcher } from '../interfaces/events/event-dispatcher.interface'\nimport { IExceptionFormatter } from '../interfaces/utils/exception-formatter.interface'\nimport { IContextLogProcessor } from '../interfaces/processors/context-log-processor.interface'\n\n// Import all implementations\nimport { ContextManager } from '../context/manager'\nimport { ContextRepository } from '../context/repository'\nimport { ExceptionFormatter } from '../utils/exception-formatter'\nimport { ContextLogProcessor } from '../processors/context-log-processor'\n\n/**\n * ContextServiceProvider is an implementation of the IContextServiceProvider interface.\n * It provides methods for registering context management services in a dependency injection container.\n */\n@injectable()\nexport class ContextServiceProvider extends ServiceProvider {\n  /**\n   * Register the context management services in the container\n   */\n  public register(): void {\n    // Register context management services\n    this.app.bind<IContextManagement>(IContextManagement.$).to(ContextRepository).inSingletonScope()\n\n    // Register context log processor\n    this.app\n      .bind<IContextLogProcessor>(IContextLogProcessor.$)\n      .to(ContextLogProcessor)\n      .inSingletonScope()\n\n    // Register utility services\n    this.app.bind<IContextManager>(IContextManager.$).to(ContextManager).inSingletonScope()\n    this.app\n      .bind<IExceptionFormatter>(IExceptionFormatter.$)\n      .to(ExceptionFormatter)\n      .inSingletonScope()\n  }\n\n  /**\n   * Boot the context management services\n   */\n  public boot(): void {\n    // Get the context repository\n    const contextRepository = this.app.make<IContextManagement>(IContextManagement.$)\n\n    // Get the context log processor\n    const contextLogProcessor = this.app.make<IContextLogProcessor>(IContextLogProcessor.$)\n\n    // Set up event listeners for context events\n    const eventDispatcher = this.app.make<IEventDispatcher>(IEventDispatcher.$)\n\n    // Add default context values if needed\n    contextRepository.add('app', 'ts-logger')\n    contextRepository.add('startTime', new Date().toISOString())\n  }\n}\n"]}
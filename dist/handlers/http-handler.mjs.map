{"version":3,"sources":["../../src/handlers/http-handler.ts"],"names":[],"mappings":"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","file":"http-handler.mjs","sourcesContent":["import { injectable } from 'inversify'\n\nimport type { LogRecord } from '../types/log-record.type'\nimport type { IHttpHandler } from '../interfaces/handlers/http-handler.interface'\n\n/**\n * HttpHandler is an implementation of the IHttpHandler interface.\n * It handles log records by sending them to a remote server via HTTP.\n */\n@injectable()\nexport class HttpHandler implements IHttpHandler {\n  private name = 'http'\n  private next: IHttpHandler | null = null\n  private url = ''\n  private method = 'POST'\n  private headers: Record<string, string> = {\n    'Content-Type': 'application/json',\n  }\n  private maxRetries = 3\n\n  /**\n   * Create a new HttpHandler instance\n   * @param options Options for the handler\n   */\n  constructor(\n    options: {\n      url?: string\n      method?: string\n      headers?: Record<string, string>\n      maxRetries?: number\n    } = {},\n  ) {\n    if (options.url) {\n      this.url = options.url\n    }\n    if (options.method) {\n      this.method = options.method\n    }\n    if (options.headers) {\n      this.headers = { ...this.headers, ...options.headers }\n    }\n    if (options.maxRetries !== undefined) {\n      this.maxRetries = options.maxRetries\n    }\n  }\n\n  /**\n   * Handle a log record\n   * @param record The log record to handle\n   */\n  public async handle(record: LogRecord): Promise<void> {\n    if (!this.url) {\n      console.error('HTTP handler URL not configured')\n      return\n    }\n\n    const payload = {\n      level: record.level,\n      levelName: record.levelName,\n      message: record.message,\n      context: record.context,\n      datetime: record.datetime.toISOString(),\n      stack: record.stack,\n    }\n\n    let retries = 0\n    let success = false\n\n    while (!success && retries <= this.maxRetries) {\n      try {\n        const response = await fetch(this.url, {\n          method: this.method,\n          headers: this.headers,\n          body: JSON.stringify(payload),\n        })\n\n        if (response.ok) {\n          success = true\n        } else {\n          retries++\n          if (retries <= this.maxRetries) {\n            // Wait before retrying (exponential backoff)\n            await new Promise((resolve) => setTimeout(resolve, 1000 * Math.pow(2, retries - 1)))\n          }\n        }\n      } catch (error) {\n        retries++\n        if (retries <= this.maxRetries) {\n          // Wait before retrying (exponential backoff)\n          await new Promise((resolve) => setTimeout(resolve, 1000 * Math.pow(2, retries - 1)))\n        } else {\n          console.error('Failed to send log to HTTP endpoint:', error)\n        }\n      }\n    }\n\n    // Pass the record to the next handler in the chain\n    if (this.next) {\n      this.next.handle(record)\n    }\n  }\n\n  /**\n   * Check if the handler can handle the log record\n   * @param record The log record to check\n   */\n  public isHandling(record: LogRecord): boolean {\n    return !!this.url && typeof fetch !== 'undefined'\n  }\n\n  /**\n   * Set the next handler in the chain\n   * @param handler The next handler\n   */\n  public setNext(handler: IHttpHandler): IHttpHandler {\n    this.next = handler\n    return handler\n  }\n\n  /**\n   * Get the next handler in the chain\n   */\n  public getNext(): IHttpHandler | null {\n    return this.next\n  }\n\n  /**\n   * Get the handler name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Set the name of the handler\n   * @param name The name to set\n   */\n  public setName(name: string): void {\n    this.name = name\n  }\n\n  /**\n   * Get the URL to send log records to\n   */\n  public getUrl(): string {\n    return this.url\n  }\n\n  /**\n   * Set the URL to send log records to\n   * @param url The URL\n   */\n  public setUrl(url: string): void {\n    this.url = url\n  }\n\n  /**\n   * Get the HTTP method to use\n   */\n  public getMethod(): string {\n    return this.method\n  }\n\n  /**\n   * Set the HTTP method to use\n   * @param method The HTTP method\n   */\n  public setMethod(method: string): void {\n    this.method = method\n  }\n\n  /**\n   * Get the HTTP headers to include in requests\n   */\n  public getHeaders(): Record<string, string> {\n    return this.headers\n  }\n\n  /**\n   * Set the HTTP headers to include in requests\n   * @param headers The HTTP headers\n   */\n  public setHeaders(headers: Record<string, string>): void {\n    this.headers = headers\n  }\n\n  /**\n   * Get the maximum number of retry attempts\n   */\n  public getMaxRetries(): number {\n    return this.maxRetries\n  }\n\n  /**\n   * Set the maximum number of retry attempts\n   * @param maxRetries The maximum number of retry attempts\n   */\n  public setMaxRetries(maxRetries: number): void {\n    this.maxRetries = maxRetries\n  }\n}\n"]}
{"version":3,"sources":["../../src/channels/single-channel.ts","../../src/interfaces/events/event-dispatcher.interface.ts","../../src/channels/stack-channel.ts"],"names":["IEventDispatcher","injectable"],"mappings":"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","file":"index.mjs","sourcesContent":["import { injectable } from 'inversify'\n\nimport type { LogContext, LogRecord } from '../types'\nimport type { LogLevel } from '../enums/log-level.enum'\nimport type { ILogHandler } from '../interfaces/handlers/log-handler.interface'\nimport type { ISingleChannel } from '../interfaces/channels/single-channel.interface'\nimport type { ILogFormatter } from '../interfaces/formatters/log-formatter.interface'\nimport type { ILogProcessor } from '../interfaces/processors/log-processor.interface'\n\n/**\n * SingleChannel is an implementation of the ISingleChannel interface.\n * It uses a single handler to process log messages.\n */\n@injectable()\nexport class SingleChannel implements ISingleChannel {\n  private name: string\n  private handler: ILogHandler\n  private formatter: ILogFormatter\n  private processors: ILogProcessor[] = []\n  private context: LogContext = {}\n\n  /**\n   * Create a new SingleChannel instance\n   * @param name The channel name\n   * @param handler The handler to use\n   * @param formatter The formatter to use\n   */\n  constructor(name: string, handler: ILogHandler, formatter: ILogFormatter) {\n    this.name = name\n    this.handler = handler\n    this.formatter = formatter\n  }\n\n  /**\n   * Log a message at the specified level\n   * @param level The log level\n   * @param message The message to log\n   * @param context Optional contextual data\n   */\n  public log(level: LogLevel, message: string, context: LogContext = {}): void {\n    // Create a log record\n    let record: LogRecord = {\n      level: level,\n      levelName: level.toUpperCase(),\n      message: message,\n      context: { ...this.context, ...context },\n      datetime: new Date(),\n    }\n\n    // Process the record with all processors\n    record = this.processRecord(record)\n\n    // Handle the record\n    if (this.handler.isHandling(record)) {\n      this.handler.handle(record)\n    }\n  }\n\n  /**\n   * Add contextual data to all subsequent log messages\n   * @param context The contextual data to add\n   */\n  public withContext(context: LogContext): ISingleChannel {\n    this.context = { ...this.context, ...context }\n    return this\n  }\n\n  /**\n   * Remove contextual data from all subsequent log messages\n   * @param keys The keys to remove from the context\n   */\n  public withoutContext(keys: string[]): ISingleChannel {\n    const newContext: LogContext = { ...this.context }\n    for (const key of keys) {\n      delete newContext[key]\n    }\n    this.context = newContext\n    return this\n  }\n\n  /**\n   * Get the channel name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Process a log record\n   * @param record The log record to process\n   */\n  public processRecord(record: LogRecord): LogRecord {\n    let processedRecord = record\n\n    // Process the record with all processors\n    for (const processor of this.processors) {\n      processedRecord = processor.process(processedRecord)\n    }\n\n    return processedRecord\n  }\n\n  /**\n   * Share context across channels\n   * @param context The contextual data to share\n   */\n  public shareContext(context: LogContext): void {\n    this.context = { ...this.context, ...context }\n  }\n\n  /**\n   * Flush shared context\n   */\n  public flushSharedContext(): void {\n    this.context = {}\n  }\n\n  /**\n   * Get the handler used by the channel\n   */\n  public getHandler(): ILogHandler {\n    return this.handler\n  }\n\n  /**\n   * Set the handler used by the channel\n   * @param handler The handler to use\n   */\n  public setHandler(handler: ILogHandler): void {\n    this.handler = handler\n  }\n\n  /**\n   * Get the formatter used by the channel\n   */\n  public getFormatter(): ILogFormatter {\n    return this.formatter\n  }\n\n  /**\n   * Set the formatter used by the channel\n   * @param formatter The formatter to use\n   */\n  public setFormatter(formatter: ILogFormatter): void {\n    this.formatter = formatter\n  }\n\n  /**\n   * Get the processors used by the channel\n   */\n  public getProcessors(): ILogProcessor[] {\n    return this.processors\n  }\n\n  /**\n   * Add a processor to the channel\n   * @param processor The processor to add\n   */\n  public addProcessor(processor: ILogProcessor): void {\n    this.processors.push(processor)\n  }\n\n  /**\n   * Remove a processor from the channel\n   * @param name The name of the processor to remove\n   */\n  public removeProcessor(name: string): void {\n    this.processors = this.processors.filter((processor) => processor.getName() !== name)\n  }\n}\n","import type { ILogEvent } from './log-event.interface'\nimport type { LogListener } from '../../types/log-listener.type'\n\n/**\n * IEventDispatcher defines the contract for event dispatchers.\n * It provides methods for dispatching events and managing event listeners.\n */\nexport interface IEventDispatcher {\n  /**\n   * Dispatch an event\n   * @param event The event to dispatch\n   */\n  dispatch(event: ILogEvent): void\n\n  /**\n   * Add a listener for an event\n   * @param eventName The event name\n   * @param listener The event listener\n   */\n  addListener(eventName: string, listener: LogListener): void\n\n  /**\n   * Remove a listener for an event\n   * @param eventName The event name\n   * @param listener The event listener\n   */\n  removeListener(eventName: string, listener: LogListener): void\n\n  /**\n   * Get all listeners for an event\n   * @param eventName The event name\n   */\n  getListeners(eventName: string): LogListener[]\n\n  /**\n   * Check if an event has listeners\n   * @param eventName The event name\n   */\n  hasListeners(eventName: string): boolean\n\n  /**\n   * Remove all listeners for an event\n   * @param eventName The event name\n   */\n  clearListeners(eventName: string): void\n}\n\n/**\n * Namespace containing symbols for dependency injection\n */\nexport namespace IEventDispatcher {\n  /**\n   * Symbol for injecting the event dispatcher\n   */\n  export const $ = Symbol.for('IEventDispatcher')\n}\n","import { injectable, inject } from 'inversify'\n\nimport type { LogContext, LogRecord } from '../types'\nimport type { LogLevel } from '../enums/log-level.enum'\nimport { IEventDispatcher } from '../interfaces/events/event-dispatcher.interface'\nimport type { IStackChannel } from '../interfaces/channels/stack-channel.interface'\nimport type { ILoggingChannel } from '../interfaces/channels/logging-channel.interface'\n\n/**\n * StackChannel is an implementation of the IStackChannel interface.\n * It combines multiple channels into a single channel.\n */\n@injectable()\nexport class StackChannel implements IStackChannel {\n  private name: string\n  private context: LogContext = {}\n  private channels: ILoggingChannel[] = []\n\n  /**\n   * Create a new StackChannel instance\n   * @param name The channel name\n   * @param eventDispatcher The event dispatcher to use\n   */\n  constructor(name: string, @inject(IEventDispatcher.$) eventDispatcher: IEventDispatcher) {\n    this.name = name\n  }\n\n  /**\n   * Log a message at the specified level\n   * @param level The log level\n   * @param message The message to log\n   * @param context Optional contextual data\n   */\n  public log(level: LogLevel, message: string, context: LogContext = {}): void {\n    // Merge the context with the channel's context\n    const mergedContext = { ...this.context, ...context }\n\n    // Log the message to all channels in the stack\n    for (const channel of this.channels) {\n      channel.log(level, message, mergedContext)\n    }\n  }\n\n  /**\n   * Add contextual data to all subsequent log messages\n   * @param context The contextual data to add\n   */\n  public withContext(context: LogContext): ILoggingChannel {\n    this.context = { ...this.context, ...context }\n    return this\n  }\n\n  /**\n   * Remove contextual data from all subsequent log messages\n   * @param keys The keys to remove from the context\n   */\n  public withoutContext(keys: string[]): ILoggingChannel {\n    const newContext: LogContext = { ...this.context }\n    for (const key of keys) {\n      delete newContext[key]\n    }\n    this.context = newContext\n    return this\n  }\n\n  /**\n   * Get the channel name\n   */\n  public getName(): string {\n    return this.name\n  }\n\n  /**\n   * Process a log record\n   * @param record The log record to process\n   */\n  public processRecord(record: LogRecord): LogRecord {\n    // Process the record with all channels in the stack\n    let processedRecord = record\n    for (const channel of this.channels) {\n      processedRecord = channel.processRecord(processedRecord)\n    }\n    return processedRecord\n  }\n\n  /**\n   * Share context across channels\n   * @param context The contextual data to share\n   */\n  public shareContext(context: LogContext): void {\n    for (const channel of this.channels) {\n      channel.shareContext(context)\n    }\n  }\n\n  /**\n   * Flush shared context\n   */\n  public flushSharedContext(): void {\n    for (const channel of this.channels) {\n      channel.flushSharedContext()\n    }\n  }\n\n  /**\n   * Get the channels in the stack\n   */\n  public getChannels(): ILoggingChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Add a channel to the stack\n   * @param channel The channel to add\n   */\n  public addChannel(channel: ILoggingChannel): void {\n    this.channels.push(channel)\n  }\n\n  /**\n   * Remove a channel from the stack\n   * @param name The name of the channel to remove\n   */\n  public removeChannel(name: string): void {\n    this.channels = this.channels.filter((channel) => channel.getName() !== name)\n  }\n\n  /**\n   * Check if the stack contains a channel with the specified name\n   * @param name The channel name\n   */\n  public hasChannel(name: string): boolean {\n    return this.channels.some((channel) => channel.getName() === name)\n  }\n\n  /**\n   * Get the channel with the specified name\n   * @param name The channel name\n   */\n  public getChannel(name: string): ILoggingChannel | undefined {\n    return this.channels.find((channel) => channel.getName() === name)\n  }\n}\n"]}